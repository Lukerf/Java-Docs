### 链表

**如何写好链表操作的代码**

1. 防止指针丢失，指着指着就弄丢了
2. 利用哨兵简化实现难度，声明一个空节点node，他的next一直指向头结点node.next=head，这样在删除和插入的时候，不用考虑插入第一个或者删除的是最后一个这些特殊情况，
3. 画图辅助思考
4. 留意边界条件处理，考虑以下几种情况

- - 如果链表为空时，代码是否能正常工作？
  - 如果链表只包含一个结点时，代码是否能正常工作？
  - 如果链表只包含两个结点时，代码是否能正常工作？
  - 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

#### 解题思路

1. 快慢指针，比如寻找倒数第n个节点，可以让快指针先走n个节点，快指针走到链表最后的时候，慢指针的位置就是倒数第n个节点

2. 还是快慢指针，快指针的速度是慢指针的两倍，这样可以找到中间节点，用于归并排序







### 动态规划

参考内容：https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-1e688/

一般都是用来求最值问题，其实就是通过自顶像下，或者自下至顶的方式，穷举出所有情况。然后可以利用**备忘录**优化或者**[DP table]**优化穷举过程

**状态转移方程**

![fib](E:\学习资料\笔记\Java-Docs\图片\fib.png)

```java
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)

```

![image-20230625233214945](C:\Users\YXG\AppData\Roaming\Typora\typora-user-images\image-20230625233214945.png)





### 二叉树

三种遍历：前序，中序，后序

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**

前序位置的代码在刚刚进入一个二叉树节点的时候执行；

后序位置的代码在将要离开一个二叉树节点的时候执行；

中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。



#### 解题思路

1. 遍历二叉树计算答案：对应动态规划

2. 分解问题计算答案，比如当前节点的值或者属性=子节点值+1之类的，核心在于确认可以通过子树计算原树的值，也就是说主要逻辑放在后序。：对应回溯算法







#### 思考过程

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫分解问题的思维模式

**3、两种思路都要明确在每一个节点要做什么（前，中，后）**

**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。