### 链表

**如何写好链表操作的代码**

1. 防止指针丢失，指着指着就弄丢了
2. 利用哨兵简化实现难度，声明一个空节点node，他的next一直指向头结点node.next=head，这样在删除和插入的时候，不用考虑插入第一个或者删除的是最后一个这些特殊情况，
3. 画图辅助思考
4. 留意边界条件处理，考虑以下几种情况

- - 如果链表为空时，代码是否能正常工作？
  - 如果链表只包含一个结点时，代码是否能正常工作？
  - 如果链表只包含两个结点时，代码是否能正常工作？
  - 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

#### 解题思路

1. 快慢指针，比如寻找倒数第n个节点，可以让快指针先走n个节点，快指针走到链表最后的时候，慢指针的位置就是倒数第n个节点

2. 还是快慢指针，快指针的速度是慢指针的两倍，这样可以找到中间节点，用于归并排序







### 动态规划

参考内容：https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-1e688/

一般都是用来求最值问题，其实就是通过自顶像下，或者自下至顶的方式，穷举出所有情况。然后可以利用**备忘录**优化或者**[DP table]**优化穷举过程

**状态转移方程**

![fib](E:\学习资料\笔记\Java-Docs\图片\fib.png)

```java
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)

```

![image-20230625233214945](C:\Users\YXG\AppData\Roaming\Typora\typora-user-images\image-20230625233214945.png)