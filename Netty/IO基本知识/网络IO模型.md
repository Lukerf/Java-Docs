### 1. IO

概念：数据的读取和写入操作，和等待读取/写出数据的过程。一个完整的IO分为两个阶段：用户进程空间-->内核空间，内核空间-->设备空间（磁盘、网络）。IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。

网络IO: 等待的过程就是数据从网络到网卡再到内核空间。读写的过程就是内核空间和用户空间的相互拷贝

### 2. 网络IO模型

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c6cce38edfd4131a6844673875055bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

同步和异步（是否立马返回结果，如果不是通过状态或者回调等方式通知）

同步是指用户空间必须拿到数据才能继续执行

异步是指用户空间不用拿到IO数据就能继续执行



阻塞和非阻塞（是否阻塞线程）

阻塞IO是指用户线程参与等待数据，以及拷贝数据的过程，被阻塞在了IO上

非阻塞IO是指用户线程不参与等待数据和拷贝数据的过程，数据到了以后才通知用户线程继续往下操作

**同步是两个对象之间的关系，而阻塞是一个对象的状态。**

#### 2.1 BIO

阻塞IO模型，进程发起IO系统调用以后，进程被阻塞，转到内核空间处理，整个IO处理完毕返回进程。

开发容易，实现简单

不适合并发量大的应用，因为一个请求IO会阻塞经常，所以需要为每个请求分配一个处理进程（线程），系统开销大

#### 2.2 NIO

非阻塞IO模型，

#### 2.3 IO多路复用模型





#### 2.4 信号/事件驱动IO模型

相比于IO多路复用，select虽然不会阻塞，但是还是需要自己去查询是否有数据已经准备好了，

信号驱动就是由内核告知数据已经准备就绪，然后用户线程再去read

#### 2.5 异步IO模型

信号驱动虽然异步了，但是read操作还是阻塞的，而真正的异步IO，是read也不阻塞，在调用时告诉需要缓存到的内存地址，拷贝完成以后再告知用户线程，调用之前设置的回调

但是因为Linux对异步IO支持不足，所以现在主流还是用I/O多路复用
