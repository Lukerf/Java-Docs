#### 概览：

Java内存模型 一种屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的访问效果的一种规范。目的是解决由于多线程通过共享内存进行通讯的时候一些原子性，可见性以及有序性的问题

#### 主内存与工作内存：

所有变量都存在主内存，如果线程要对变量进行操作，需要先将变量从主内存读取到工作内存才能操作。

#### 内存间交互的操作：

lock 锁定主内存变量

unlock 解锁主内存变量

read ,load,use  三个操作将变量从主内存，读取到工作内存，并交给执行引擎

assign(赋值)，store,write  三个操作将变量从执行引擎取到值以后，放入工作内存，在放入主内存。  

**由于主内存和工作内存的存在，会导致多线程线程访问内  n 存时并不一定一直都是最新的，因此定义了一套规范来确定哪些内存访问操作在并发下是安全的**，主要包括:volatile，synchronized,final。以及happens-before规则（不用记每个规则，大概就是一些先行发生关系）

#### volatile:

1. 被修饰的变量能保证对所有线程的可见性，即修改以后立即对所有线程可见。通过在变量读取前从主内存刷新变量值来保证。
2. 禁止指令重排序

#### happens-before规则

1. 程序的顺序性规则：这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。

2. volatile变量规则：这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。

3. 传递性规则：这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

4. 管程中锁的规则：这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。

   ```java
   synchronized (this) { //此处自动加锁  
       // x是共享变量,初始值=10  
       if (this.x < 12) { 
           this.x = 12;
       }
   } //此处自动解锁         
   ```

5. 线程start()规则：它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。

6. 线程join()规则：它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。

原子性：一个操作要么都不执行，要么都执行成功

可见性：一个线程修改了变量，另一个线程立刻知道。volatile,synchronized,final实现保证。

有序性：程序按代码先后顺序执行，volatile禁止指令重排序