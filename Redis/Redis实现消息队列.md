### 1. 使用场景

轻量级的消息队列，不需要引入额外的组件，只需要启动一个Redis实例。如果应用场景压力大，则不适合，因为需要面对高流量的积压问题，更建议使用kafak,rabbitmq等专业的消息队列。同时redis写后日志的特效，决定了作为消息中间件不能完全保证消息不丢失



### 2. 利用List实现消息队列

#### 2.1 保证消息有序

List本身就是有序的

LPUSHU命令：发送消息

RPOP: 依次读取消息，为了及时处理消息，消费者需要循环调用RPOP，造成性能损失

BRPOP: 阻塞式读取消息，队列没有数据时，自动阻塞，直到有新的数据写入队列

#### 2.2 保证消息不可重复消费

设定唯一ID的校验，唯一ID可以生产者生成，也可以使用Redis自动生成

#### 2.3 保证消息的可靠性

生产者：发布失败就报错，发布超时则重新发布，但是要做幂等校验

消费者：处理失败从Redis的备份List中再读取，并且每次处理完成以后，都删除备份List中的消息，节省存储

中间件：依赖Redis的持久化，不能完全做到消息不丢失



### 3. 利用Streams的消息队列（5.0版本以后）

- XADD：插入消息，保证有序，可以自动生成全局唯一 ID；
- XREAD：用于读取消息，可以按 ID 读取数据；
- XREADGROUP：按消费组形式读取消息；
- XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。

**对比List的方式，可以自动生成唯一ID,ACK机制更加优雅，可以按消费组消费消息**



