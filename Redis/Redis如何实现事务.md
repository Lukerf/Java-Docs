### 实践案例

#### MULTI 命令：开启事务，后续的所有命令都会被暂存到队列中

#### EXEC命令：提交事务并执行

```
#开启事务
127.0.0.1:6379> MULTI
OK
#将a:stock减1，
127.0.0.1:6379> DECR a:stock
QUEUED
#将b:stock减1
127.0.0.1:6379> DECR b:stock
QUEUED
#实际执行事务
127.0.0.1:6379> EXEC
1) (integer) 4
2) (integer) 9
```

#### WATCH 命令：监控键是否被别的客户端修改

```
#开启事务
127.0.0.1:6379> MULTI
OK
#将a:stock减1，
127.0.0.1:6379> DECR a:stock
QUEUED
#将b:stock减1
127.0.0.1:6379> DECR b:stock
QUEUED
#监视a:stock，在事务的执行过程中，如果发现a:stock被其他客户端修改了，那么事务操作就会被取消
127.0.0.1:6379> WATCH a:stock
OK
#实际执行事务
127.0.0.1:6379> EXEC
1) (integer) 4
2) (integer) 9
```

#### DISCARD命令：清空暂存命令队列

**实际使用最好写Lua脚本，避免一次次的提交过程中，其他客户端修改了打算修改的值。pipeline只能减少减少网络IO,分批次将命令发送到redis server**



### Redis的ACID属性

#### 原子性

1. 如果在**执行EXEC命令前**，客户端的命令就有错，则直接判断失败，不执行事务，所有命令都不执行，**可以保证原子性。**
2. 如果在**调用EXEC命令后**，执行到某条命令以后有错，此时Redis会报错，但是还是会把所有正确的命令执行完，这个清空就**不能保证原子性**。
3. 如果在**调用EXEC命令后，实例发生故障**，导致事务执行失败。这种情况如果开启了AOF日志，是可以在AOF日志中，使用redis-check-aof工具检查**AOF**日志文件，如果存在没有执行完的事务，则丢弃，此时是**可以保证原子性**的，但是如果没有开启AOF日志，此时只能通过**RDB文件恢复**数据，而且RDB快照不会在事务执行的时候执行，所以只是会丢失一部分数据，也**可以保证原子性。**

#### 一致性（同原子性）

1. 执行命令前报错：可以保证一致性
2. 调用EXEC命令后：不能保证一致性 （这种情况，在事务中部分执行成功，部分执行失败，由于redis的定义中不同key之间并没有维护关系，所以也能叫做保证了一致性）
3. 调用EXEC命令后，实例发生故障：可以保证一致性。

#### 隔离性

1. 并发操作在执行EXEC命令前，隔离性需要使用WATCH命令来实现
2. 并发操作执行EXEC命令后，redis是单线程的，隔离性可以保证

#### 持久性

取决于Redis是否开启了AOF和RDB日志配置，不过即便AOF和RDB都开启了，这两种日志都是写后日志，不像Mysql是WAL(Write Ahead Logging),所以是有可能出现数据丢失，保证不了持久性，